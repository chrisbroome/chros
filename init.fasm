; Copyright 2011 Christopher Broome

; init will be loaded by loader.asm

; interrupts
INT_BIOS_DISK  = 0x13
INT_BIOS_VIDEO = 0x10

CR = 0x0d
LF = 0x0a

; 8043 Keyboard Controller Port Mapping
PORT_IN_KBD_READ_INPUT_BUFFER    = 0x60
PORT_OUT_KBD_WRITE_OUTPUT_BUFFER = 0x60
PORT_IN_KBD_READ_STATUS_REGISTER = 0x64
PORT_OUT_KBD_SEND_COMMAND        = 0x64

; Keyboard status register bits
KSR_OUTPUT_BUFFER_STATUS         = 0x01 ; 0: buffer empty, do not read.  1: buffer full, ok to read
KSR_INPUT_BUFFER_STATUS          = 0x02 ; 0: buffer empty, ok to write.  1: buffer full, do not write
KSR_SYSTEM_FLAG                  = 0x04 ; 0: After power on reset.  1: After successfull completion of the keyboard controllers self-test
KSR_COMMAND_DATA                 = 0x08 ; 0: Last write was data (via port 0x60).  1: last write was a command (via port 0x64)
KSR_KEYBOARD_UNLOCKED            = 0x10 ; 0: Locked, 1: Not Locked
KSR_AUXILIARY_OUTPUT_BUFFER_FULL = 0x20 ; AT: 0: OK Flag.  1: Timeout on transmission from keyboard controller to keyboard.  Could indicate no keyboard present.
KSR_TIMEOUT                      = 0x40 ; 0: OK flag.  1: Timeout.  PS/2 General Timeout.  AT: Timeout on transsmission from keyboard to keyboard controller.  Possibly parity error (in which case bits 6 and 7 are set)
KSR_PARITY_ERROR                 = 0x80 ; 0: OK flag, no err.  1: Parity error with last byte

; Keyboard Commands
KBCMD_READ_OUTPUT_PORT  = 0xd0
KBCMD_WRITE_OUTPUT_PORT = 0xd1
KBCMD_ENABLE_A20        = 0xdd
KBCMD_DISABLE_A20       = 0xdf

; our loader loads us at physical address 0x8000
START_ADDRESS = 0x8000
; org START_ADDRESS 

org 0 ; offset to 0, we will set segments later
use16 ; we are still in real mode here, but we'll switch later

; this should go above any other includes or assembly code
  jmp main   ; jump to the main program

macro outportb port, b {
  if b eq
  else
    mov al, b
  end if
  out port, al
}

macro outportw port, w {
  if w eq
  else
    mov ax, w
  end if
  out port, ax
}

macro inportb port, b {
  in al, port
  if b eq
  else
    mov b, al
  end if
}

macro inportw port, w {
  in ax, port
  if w eq
  else
    mov w, ax
  end if
}

; this gets the a20 address line status comparing the word at 0x00000 with the word at 0x100000
; if a20 is enabled, then changing one value does not affect the other
; if a20 is disabled, they are effectively the same address because wrapping occurs
; the status is returned in the carry bit
get_a20_status:
    push ds
    push es
    mov ax,0x0000
    mov bx,0xFFFF
    mov ds,ax
    mov es,bx
    mov ax,[ds:0x0000]   ; ax = word at 0x0000:0x0000 (0x00000000)
    cmp [es:0x0010],ax   ; Is it the same as the word at 0xFFFF:0x0010 (0x00100000)?
    jne .enabled         ; no, A20 must be enabled
    pushf                ; save the status of the flags so that we can restore them
    cli                  ; what we're about to do will modify the interrupt vector table,
                         ; specifically interrupt 0, if a20 is disabled
    inc word [es:0x0010] ; Change the word at 0xFFFF:0x0010 (0x00100000)
    ;wbinvd               ; Flush caches (normally not necessary, but done just in case) 486+ only
    cmp [ds:0x0000],ax   ; Did the word at 0x0000:0x0000 (0x00000000) change?
    je .disabled         ; yes, A20 must be disabled

    dec word [es:0x0010] ; Restore the word at 0xFFFF:0x0010
    popf                 ; restore the flags (possibly reenable interrupts if they were enabled beforehand)
.enabled:
    pop es
    pop ds
    stc    ; return cf = 1 if enabled
    ret

.disabled:
    dec word [es:0x0010] ; Restore the word at 0xFFFF:0x0010 and 0x0000:0x0000 (it's the same memory location)
    popf                 ; restore the flags (possibly reenable interrupts if they were enabled beforehand)
    pop es
    pop ds
    clc    ; return cf = 0 if disabled
    ret

bios_enable_a20:
  mov ax, 0x2401 ; enable a20
  int 0x15       ;
  ret

kbd_wait_input:
  inportb PORT_IN_KBD_READ_STATUS_REGISTER ; read the status register
  test al, KSR_INPUT_BUFFER_STATUS         ; test the input buffer status
  jnz  kbd_wait_input                      ; keep waiting until it's ok to read (0)
  ret

kbd_wait_output:
  inportb PORT_IN_KBD_READ_STATUS_REGISTER ; read the status register
  test al, KSR_OUTPUT_BUFFER_STATUS        ; test the output buffer status
  jz   kbd_wait_output                    ; keep waiting until it's ok to write (1)
  ret

kbd_enable_a20:
  ; send the read the output port command
  outportb PORT_OUT_KBD_SEND_COMMAND, KBCMD_READ_OUTPUT_PORT
  call kbd_wait_output              ; wait for the output buffer to be empty

  ; read input buffer
  inportb PORT_IN_KBD_READ_INPUT_BUFFER
  push ax             ; store the value on the stack
  call kbd_wait_input ; wait for the input buffer to clear

  ; send the write output port command
  outportb PORT_OUT_KBD_SEND_COMMAND, KBCMD_WRITE_OUTPUT_PORT
  call kbd_wait_input 

  pop ax       ; pop the old value of the keyboard status into ax
  or  al, 0x02 ; set the A20 bit
  outportb PORT_OUT_KBD_WRITE_OUTPUT_BUFFER ; write the value in al back to the keyboard output buffer
  ret

; outputs a null terminated string to the console using the BIOS
; the first parameter is a pointer to the string
bios_puts:
label page_and_color at bp+6
label string_addr at bp+4
  enter 0, 0      ; set up a stack frame
  push bx
  push si
  pushf
  mov ah, 0x0e             ; BIOS function to output a character
  mov bx, [page_and_color] ; 0 page, 7 attribute (normal text color)
  mov si, [string_addr]    ; move the address to si
  cld
.loop:
  lodsb           ; load al with the byte at [ds:si]
                  ; and increment si
  cmp al, 0       ; if al == 0
  je .done        ; goto .done
                  ; else
  int INT_BIOS_VIDEO  ; call the BIOS video interrupt to output the character
  jmp .loop       ; loop again
.done:
  popf
  pop si
  pop bx
  leave           ; restore bp
  ret 2           ; pop parameters ourselves

macro bios_puts_color message, color {
  push color
  push message
  call bios_puts
}

macro bios_puts_normal message {
  bios_puts_color message, 0x0007
}

macro bios_puts_error message {
  bios_puts_color message, 0x000c
}

macro bios_puts_good message {
  bios_puts_color message, 0x000a
}

; calculates the linear address of the gdt at runtime and updates the gdt_desc 
; appropriately so that we don't have to depend on compile time constants
; for the gdt_desc.address pointer
install_gdt:
  pusha
  xor eax, eax       ; zero out eax
  mov ax, ds         ; lgdt uses the data segment as its default segment
  shl eax, 4         ; multiply eax by 16
  add eax, gdt_start ; add the offset
  mov dword [gdt_desc.address], eax ; set the gdt_desc's pointer
  mov eax, gdt_end   ;
  sub eax, gdt_start ;
  mov word [gdt_desc.limit], ax
  popa
  lgdt [gdt_desc] ; load the global descriptor table
  ret

; Stage 2 entry point
main:
  cli ; clear interrupts
             ; align all our segments
  mov ax, cs ; set ax = cs
  mov ds, ax ; set ds = cs
  mov es, ax ; set es = cs
  sti

  ; display the loading message
  bios_puts_normal sys_msgs.loading

  ; here we'll try several different methods of enabling A20 in the hopes that one will work
  call get_a20_status ; gets the a20 line status. cf = 1 if enabled, 0 if disabled
  jc  .enabled_a20     ; if carry was set, the line is disabled, so we need to enable it
  bios_puts_error a20_msgs.disabled

  bios_puts_normal a20_msgs.trying_fast
  call bios_enable_a20 ; call the bios to enable the a20 line
  call get_a20_status  ; get the status of the a20 line
  jc  .enabled_a20      ; if carry was set, the line is disabled, so we try again

  bios_puts_normal a20_msgs.trying_kbc
  call kbd_enable_a20 ; call the routine to enable the a20 line
  call get_a20_status ; get the status again
  jc  .enabled_a20    ; if carry was set, the line is disabled and we'll fall through and halt

  bios_puts_error a20_msgs.failed_to_enable
  jmp .display_halt_msg
.enabled_a20:
  bios_puts_good a20_msgs.enabled
  jmp .gdt
.display_halt_msg:
  bios_puts_error sys_msgs.halting
.halt_os:
  cli
  hlt ; halt the system.
  jmp .halt_os

.gdt:
  cli
; load our GDT
  call install_gdt
;  sti            ; enable interrupts
  ; go into protected mode
  mov eax, cr0 ; move the old cr0 to eax
  or  eax, 1   ; set bit 0 of eax
  mov cr0, eax ; mov eax back to cr0 (enable protected mode)

  ; we're now in protected mode, so we must perform a far jump to set cs to the
  ; correct code segment descriptor as we defined below
  jmp fword 0x08:(START_ADDRESS + stage3)

; Stage 3 of our boot loader
;   We're in protected mode!  Don't enable interrupts yet
stage3:
use32 ; we're in 32 bit mode here
  mov ax, 0x10 ; set segment registers to data selector
  mov ds, ax
  mov ss, ax
  mov es, ax
  mov esp, 0x90000  ; set up our stack to start at 0x90000

  mov edi, 0xb8000  ; load the address of video ram into edi
  mov esi, START_ADDRESS + PM_Sig ; load the signiture
  xor ecx, ecx      ; ecx is our counter
  cld
.print_msg:
  lodsb             ; load a byte from ds:esi into al and increment esi
  cmp al, 0 ; are we done?
  je .done
  mov byte [edi + ecx * 2], al
  mov byte [edi + ecx * 2 + 1], 0x1b
  inc ecx
  jmp .print_msg

.done:

; just stop execution
.haltloop:
  cli     ; clear all interrupts and halt the processor
  hlt     ; halt the system
  jmp .haltloop

; global descriptor table
gdt_start: ; Address for the GDT
 
gdt_null: ; Null Segment
  dd 0
  dd 0
 
gdt_code: ; Code segment, read/execute, nonconforming
  dw 0xffff
  dw 0
  db 0
  db 10011010b
  db 11001111b
  db 0
 
gdt_data: ; Data segment, read/write, expand down
  dw 0xffff
  dw 0
  db 0
  db 10010010b
  db 11001111b
  db 0
 
gdt_end: ; Used to calculate the size of the GDT
 
; global descriptor table pointer format
gdt_desc:
.limit   dw 0 ; we'll calculate this at runtime
.address dd 0 ; we'll calculate this at runtime

; null terminated strings
sys_msgs:
.loading          db 'Loading OS...', CR, LF, 0
.halting          db 'Halting system', CR, LF, 0

a20_msgs:
.enabled          db 'Enabled A20', CR, LF, 0
.disabled         db 'A20 is Disabled', CR, LF, 0
.trying_fast      db 'Trying to enable using BIOS fast enable...', CR, LF, 0
.trying_kbc       db 'Trying to enable using the keyboard controller...', CR, LF, 0
.failed_to_enable db 'Failed to enable a20.', CR, LF, 0

PM_Sig: db 'Protected Mode!', 0

times (18*512)-($-$$) db 0