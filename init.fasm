; Copyright 2011 Christopher Broome

; init will be loaded by loader.asm

; interrupts
INT_BIOS_DISK  = 0x13
INT_BIOS_VIDEO = 0x10

; our loader loads us at physical address 0x8000
START_ADDRESS = 0x8000
; org START_ADDRESS 

org 0 ; offset to 0, we will set segments later
use16 ; we are still in real mode here, but we'll switch later

; this should go above any other includes or assembly code
  jmp main   ; jump to the main program

; outputs a null terminated string to the console using the BIOS
; the first parameter is a pointer to the string
bios_puts:
label string_addr at bp+4
  enter 0, 0      ; set up a stack frame
  push bx
  push si
  pushf
  mov ah, 0x0e    ; BIOS function to output a character
  mov bx, 0x0007  ; 0 page, 7 attribute (normal text color)
  mov si, [string_addr] ; move the address to si
  cld
.loop:
  lodsb           ; load al with the byte at [ds:si]
                  ; and increment si
  cmp al, 0       ; if al == 0
  je .done        ; goto .done
                  ; else
  int INT_BIOS_VIDEO  ; call the BIOS video interrupt to output the character
  jmp .loop       ; loop again
.done:
  popf
  pop si
  pop bx
  leave           ; restore bp
  ret 2           ; pop parameters ourselves

; Stage 2 entry point
main:
  cli ; clear interrupts
             ; align all our segments
  mov ax, cs ; set ax = cs
  mov ds, ax ; set ds = cs
  mov es, ax ; set es = cs

  push loading_message
  call bios_puts

; load our GDT
  lgdt [gdt_desc] ; load the gdt descriptor into GDTR
;  sti            ; enable interrupts

  ; go into protected mode
  mov eax, cr0 ; move the old cr0 to eax
  or eax, 1    ; set bit 0 of eax
  mov cr0, eax ; mov eax back to cr0 (enable protected mode)

  ; we're now in protected mode, so we must perform a far jump to set cs to the
  ; correct code segment descriptor as we defined below
;  db 0x66
;  db 0xea
;  dd stage3
;  dw 0x08
  jmp far 0x08:stage3

use32 ; we're in 32 bit mode here
; Stage 3 of our boot loader
;   We're in protected mode!  Don't enable interrupts yet
stage3:
  mov ax, 0x10 ; set segment registers to data selector
  mov ds, ax
  mov ss, ax
  mov es, ax
  mov esp, 0x90000 ; set up our stack to start at 0x90000

; just stop execution
.haltloop:
  cli     ; clear all interrupts and halt the processor
  hlt     ; halt the system
  jmp .haltloop

; null terminated strings
loading_message db 'Loading OS...', 0

; global descriptor table

gdt: ; Address for the GDT
 
gdt_null: ; Null Segment
  dd 0
  dd 0
 
gdt_code: ; Code segment, read/execute, nonconforming
  dw 0xffff
  dw 0
  db 0
  db 10011010b
  db 11001111b
  db 0
 
gdt_data: ; Data segment, read/write, expand down
  dw 0xffff
  dw 0
  db 0
  db 10010010b
  db 11001111b
  db 0
 
gdt_end: ; Used to calculate the size of the GDT
 
; global descriptor table pointer format
gdt_desc:
.limit   dw gdt_end - gdt - 1
.address dd gdt

times (18*512)-($-$$) db 0