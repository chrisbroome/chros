; Copyright 2011 Christopher Broome
match x, BIOS_IO_FINC {
  define BIOS_IO_FINC

  include "bios_int_vid.finc"

  macro _putb b \{
    push ax
    push bx
      mov ah, BIOS_INT_VID_TTY_OUTPUT
      if b eq
      else
        mov al, b
      end if
      mov bx, 0x0007
      int BIOS_INT_VID
    pop bx
    pop ax
  \}

  puthex16:
  label .mem16 at bp+4
    enter 0, 0
      pusha
        mov bx, 0x0007
        mov cx, 0x0010  ; shift amount (must be a multiple of 4)
        mov dx, 0xf000  ; mask
        mov ax, [.mem16] ; 
        .while_cx_not_zero:
          push ax
	    sub cl, 4   ; subtract 4 from cl on each pass
	    and ax, dx  ; mask out the appropriate digit
	    shr ax, cl  ; shift ax right cl times
	  .correct_digit:
	    add al, '0' ; correct digit for display
	    cmp al, '9' ; is digit a number?
	    jle .output ; digit is a number
	    add al, 'a'-('9' + 1) ; digit is a letter
	  .output:
	    mov ah, BIOS_INT_VID_TTY_OUTPUT ; output the character
	    int BIOS_INT_VID ; print the digit
	  pop ax                 ; restore ax
	  shr dx, 4              ; shift the mask right 4 times
	  jcxz .end              ; exit if cx == 0
	  jmp .while_cx_not_zero ; otherwise, do another iteration
  .end:
      popa
    leave
    ret 2

  ; prints the null (0) terminated string at ds:[bp+4]
  ; note that ds is implicitly assumed to be correct
  ; parameters: [bp+4] word offset of string value to print
  puts:
  label .msg at bp+4
    enter 0, 0 ; set up a stack frame
      pusha ; save all registers
	pushf ; save the flags register
	  mov bx, 0x0007    ; normal output
	  mov ah, BIOS_INT_VID_TTY_OUTPUT  ; output the character (al)
	  mov si, [.msg] ; offset of string
	  cld ; clear the direction flag so that we're looping forwards
	.loop:
	  lodsb ; load al with the value of the string
	  cmp al, 0
	  je .done
	  int BIOS_INT_VID  ; print the digit
	  jmp .loop
	.done:
	popf ;
      popa
    leave
    ret 2
}